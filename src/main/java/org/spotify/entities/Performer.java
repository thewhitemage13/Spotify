package org.spotify.entities;

import lombok.*;
import org.spotify.enums.Genre;

import javax.persistence.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

/**
 * Entity class representing a performer.
 * <p>
 * The {@code Performer} class maps to the {@code performers} table in the database. It represents a musical performer
 * who can have multiple music collections and songs associated with them. The performer is linked to music collections
 * and songs via one-to-many relationships.
 * </p>
 *
 * @author Mukhammed Lolo
 * @version 1.0
 */
@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
@Builder
@Entity
@Table(name = "performers")
public class Performer {

    /**
     * The unique ID of the performer.
     * <p>
     * This ID is automatically generated by the database upon insertion.
     * </p>
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long performer_id;

    /**
     * The name of the performer.
     * <p>
     * This is the performer's name as it is represented in the database.
     * </p>
     */
    @Column(name = "performer_name")
    private String name;

    /**
     * The genre of the performer.
     * <p>
     * This field represents the genre of the performer and is stored as an enum of type {@link Genre}.
     * </p>
     */
    @Enumerated(EnumType.STRING)
    private Genre genre;

    /**
     * The list of music collections associated with the performer.
     * <p>
     * This is a one-to-many relationship where a performer can have multiple music collections.
     * The relationship is mapped by the {@code performer} field in the {@link MusicCollection} class.
     * </p>
     */
    @OneToMany(mappedBy = "performer", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private List<MusicCollection> musicCollection = new ArrayList<>();

    /**
     * The list of songs associated with the performer.
     * <p>
     * This is a one-to-many relationship where a performer can have multiple songs.
     * The relationship is mapped by the {@code performer} field in the {@link Song} class.
     * </p>
     */
    @OneToMany(mappedBy = "performer", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private List<Song> songs = new ArrayList<>();

    /**
     * Adds a music collection to the performer.
     * <p>
     * This method sets the performer of the given music collection to the current performer
     * and adds the music collection to the {@code musicCollection} list.
     * </p>
     *
     * @param musicCollection the {@link MusicCollection} to be added
     */
    public void add(MusicCollection musicCollection) {
        musicCollection.setPerformer(this);
        this.musicCollection.add(musicCollection);
    }

    /**
     * Removes a music collection from the performer.
     * <p>
     * This method removes the given music collection from the {@code musicCollection} list
     * and sets its performer to {@code null}.
     * </p>
     *
     * @param musicCollection the {@link MusicCollection} to be removed
     */
    public void remove(MusicCollection musicCollection) {
        musicCollection.setPerformer(null);
        this.musicCollection.remove(musicCollection);
    }

    /**
     * Adds a song to the performer.
     * <p>
     * This method sets the performer of the given song to the current performer and
     * adds the song to the {@code songs} list.
     * </p>
     *
     * @param song the {@link Song} to be added
     */
    public void add(Song song) {
        song.setPerformer(this);
        this.songs.add(song);
    }

    /**
     * Removes a song from the performer.
     * <p>
     * This method removes the given song from the {@code songs} list and sets its performer to {@code null}.
     * </p>
     *
     * @param song the {@link Song} to be removed
     */
    public void remove(Song song) {
        song.setPerformer(null);
        this.songs.remove(song);
    }

    /**
     * Compares this performer to another object.
     * <p>
     * This method compares the performer based on their name, genre, and associated music collections.
     * </p>
     *
     * @param o the object to compare this performer against
     * @return {@code true} if the objects are considered equal, {@code false} otherwise
     */
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Performer performer = (Performer) o;
        return Objects.equals(name, performer.name) && genre == performer.genre && Objects.equals(musicCollection, performer.musicCollection);
    }

    /**
     * Returns a hash code value for this performer.
     * <p>
     * This method generates a hash code based on the name, genre, and associated music collections.
     * </p>
     *
     * @return the hash code value for this performer
     */
    @Override
    public int hashCode() {
        return Objects.hash(name, genre, musicCollection);
    }

    /**
     * Returns a string representation of the performer.
     * <p>
     * This method provides a string description of the performer, including their ID, name, genre,
     * music collections, and songs.
     * </p>
     *
     * @return a string representation of the performer
     */
    @Override
    public String toString() {
        return "Performer{" +
                "performer_id=" + performer_id +
                ", name='" + name + '\'' +
                ", genre=" + genre +
                ", musicCollection=" + musicCollection +
                ", songs=" + songs +
                '}';
    }
}
